import { writeFileSync } from 'fs';
import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import chalk from 'chalk';
import { getDatabase } from '../../storage/database.js';
import { getAllProjects, getProjectByName } from '../../storage/repositories/projects.js';
import {
  createInvoice,
  getAllInvoices,
  getInvoiceById,
  getInvoiceByNumber,
  getInvoiceLineItems,
  deleteInvoice,
  updateInvoiceStatus,
  ensureInvoicesTable,
  Invoice,
} from '../../storage/repositories/invoices.js';
import { success, error, info, formatDuration } from '../utils/format.js';

// Get package version for footer
function getPackageVersion(): string {
  try {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const packagePath = join(__dirname, '../../../package.json');
    const packageJson = JSON.parse(readFileSync(packagePath, 'utf-8'));
    return packageJson.version || '1.0.0';
  } catch {
    return '1.0.0';
  }
}

// Generate footer text
function getFooterText(): string {
  const version = getPackageVersion();
  const date = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
  return `Generated by Timer Record v${version} on ${date}`;
}

interface InvoiceEntry {
  date: string;
  category: string;
  project: string | null;
  hours: number;
  rate: number;
  amount: number;
  notes: string | null;
}

interface InvoiceData {
  project: string;
  client: string | null;
  period: string;
  entries: InvoiceEntry[];
  totalHours: number;
  totalAmount: number;
  rate: number;
}

// Generate invoice data
function generateInvoiceData(options: {
  project?: string;
  from?: string;
  to?: string;
  rate?: number;
}): InvoiceData | null {
  const db = getDatabase();

  // Get project details
  let project = null;
  let projectFilter = '';
  const params: (string | number | null)[] = [];

  if (options.project) {
    project = getProjectByName(options.project);
    if (!project) {
      return null;
    }
    projectFilter = 'AND e.project_id = ?';
    params.push(project.id);
  }

  // Get date range - use consistent Date instance
  const today = new Date();
  const firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
  const fromDate = options.from || firstOfMonth.toISOString().slice(0, 10);
  const toDate = options.to || today.toISOString().slice(0, 10);
  params.unshift(fromDate, toDate);

  // Get entries
  const entries = db.prepare(`
    SELECT
      date(e.start_time) as date,
      COALESCE(c.name, 'uncategorized') as category,
      p.name as project,
      e.duration_seconds,
      e.notes,
      COALESCE(p.hourly_rate, 0) as rate
    FROM time_entries e
    LEFT JOIN categories c ON e.category_id = c.id
    LEFT JOIN projects p ON e.project_id = p.id
    WHERE date(e.start_time) BETWEEN ? AND ?
    AND e.duration_seconds IS NOT NULL
    ${projectFilter}
    ORDER BY e.start_time
  `).all(...params) as {
    date: string;
    category: string;
    project: string | null;
    duration_seconds: number;
    notes: string | null;
    rate: number;
  }[];

  if (entries.length === 0) {
    return null;
  }

  const rate = options.rate || project?.hourly_rate || 0;

  const invoiceEntries: InvoiceEntry[] = entries.map(e => ({
    date: e.date,
    category: e.category,
    project: e.project,
    hours: e.duration_seconds / 3600,
    rate,
    amount: (e.duration_seconds / 3600) * rate,
    notes: e.notes,
  }));

  const totalHours = invoiceEntries.reduce((sum, e) => sum + e.hours, 0);
  const totalAmount = totalHours * rate;

  return {
    project: options.project || 'All Projects',
    client: project?.client || null,
    period: `${fromDate} to ${toDate}`,
    entries: invoiceEntries,
    totalHours,
    totalAmount,
    rate,
  };
}

// Generate text invoice
function generateTextInvoice(data: InvoiceData): string {
  let output = '═'.repeat(60) + '\n';
  output += '                        INVOICE\n';
  output += '═'.repeat(60) + '\n\n';

  output += `Project:    ${data.project}\n`;
  if (data.client) {
    output += `Client:     ${data.client}\n`;
  }
  output += `Period:     ${data.period}\n`;
  output += `Rate:       $${data.rate.toFixed(2)}/hour\n\n`;

  output += '─'.repeat(60) + '\n';
  output += 'Date        Category        Hours       Amount\n';
  output += '─'.repeat(60) + '\n';

  for (const entry of data.entries) {
    const date = entry.date.padEnd(12);
    // Truncate category with ellipsis if needed
    const category = entry.category.length > 15
      ? entry.category.slice(0, 12) + '...'
      : entry.category;
    const categoryPadded = category.padEnd(16);
    const hours = entry.hours.toFixed(2).padStart(6);
    const amount = ('$' + entry.amount.toFixed(2)).padStart(12);
    output += `${date}${categoryPadded}${hours}${amount}\n`;
  }

  output += '─'.repeat(60) + '\n';
  output += `TOTAL${' '.repeat(25)}${data.totalHours.toFixed(2).padStart(6)}  $${data.totalAmount.toFixed(2).padStart(10)}\n`;
  output += '═'.repeat(60) + '\n';

  return output;
}

// Generate HTML invoice
function generateHtmlInvoice(data: InvoiceData): string {
  const entriesHtml = data.entries.map(e => `
    <tr>
      <td>${e.date}</td>
      <td>${e.category}</td>
      <td class="number">${e.hours.toFixed(2)}</td>
      <td class="number">$${e.amount.toFixed(2)}</td>
    </tr>
  `).join('');

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Invoice - ${data.project}</title>
  <style>
    body { font-family: -apple-system, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto; }
    h1 { color: #333; border-bottom: 2px solid #61AFEF; padding-bottom: 10px; }
    .header { margin-bottom: 30px; }
    .header p { margin: 5px 0; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }
    th { background: #f5f5f5; }
    .number { text-align: right; }
    .total { font-weight: bold; background: #f0f0f0; }
    .footer { margin-top: 40px; text-align: center; color: #999; font-size: 12px; }
  </style>
</head>
<body>
  <h1>Invoice</h1>
  <div class="header">
    <p><strong>Project:</strong> ${data.project}</p>
    ${data.client ? `<p><strong>Client:</strong> ${data.client}</p>` : ''}
    <p><strong>Period:</strong> ${data.period}</p>
    <p><strong>Rate:</strong> $${data.rate.toFixed(2)}/hour</p>
  </div>
  <table>
    <thead>
      <tr>
        <th>Date</th>
        <th>Category</th>
        <th class="number">Hours</th>
        <th class="number">Amount</th>
      </tr>
    </thead>
    <tbody>
      ${entriesHtml}
    </tbody>
    <tfoot>
      <tr class="total">
        <td colspan="2">Total</td>
        <td class="number">${data.totalHours.toFixed(2)}</td>
        <td class="number">$${data.totalAmount.toFixed(2)}</td>
      </tr>
    </tfoot>
  </table>
  <div class="footer">${getFooterText()}</div>
</body>
</html>`;
}

// Invoice command
export function invoiceCommand(options: {
  project?: string;
  from?: string;
  to?: string;
  rate?: string;
  output?: string;
  format?: string;
}): void {
  // Validate rate if provided
  let rate: number | undefined = undefined;
  if (options.rate) {
    const parsedRate = parseFloat(options.rate);
    if (!Number.isFinite(parsedRate) || parsedRate < 0) {
      error('Invalid rate: must be a non-negative number');
      console.log();
      return;
    }
    rate = parsedRate;
  }
  const data = generateInvoiceData({
    project: options.project,
    from: options.from,
    to: options.to,
    rate,
  });

  if (!data) {
    console.log();
    if (options.project) {
      error(`Project "${options.project}" not found or no entries in period`);
    } else {
      error('No billable entries found in the specified period');
    }
    console.log();
    return;
  }

  const format = options.format || 'text';
  let content: string;

  if (format === 'html') {
    content = generateHtmlInvoice(data);
  } else {
    content = generateTextInvoice(data);
  }

  if (options.output) {
    try {
      writeFileSync(options.output, content);
      console.log();
      success(`Invoice saved to ${options.output}`);
      console.log();
    } catch (err) {
      error(`Failed to write invoice to ${options.output}: ${err instanceof Error ? err.message : 'Unknown error'}`);
      console.log();
      process.exit(1);
    }
  } else {
    console.log();
    console.log(content);
  }
}

// Preview invoice
export function invoicePreview(options: {
  project?: string;
  from?: string;
  to?: string;
}): void {
  const data = generateInvoiceData({
    project: options.project,
    from: options.from,
    to: options.to,
  });

  if (!data) {
    console.log();
    info('No billable entries found');
    console.log();
    return;
  }

  console.log();
  console.log(chalk.bold('Invoice Preview'));
  console.log();
  console.log(`  Project:     ${data.project}`);
  if (data.client) {
    console.log(`  Client:      ${data.client}`);
  }
  console.log(`  Period:      ${data.period}`);
  console.log(`  Rate:        $${data.rate.toFixed(2)}/hour`);
  console.log(`  Total Hours: ${data.totalHours.toFixed(2)}`);
  console.log(`  Total:       ${chalk.green('$' + data.totalAmount.toFixed(2))}`);
  console.log(`  Entries:     ${data.entries.length}`);
  console.log();
  info('Generate with: tt invoice create --project <name>');
  console.log();
}

// Parse month option into date range
function parseMonthToRange(month: string): { from: string; to: string } | null {
  const match = month.match(/^(\d{4})-(\d{2})$/);
  if (!match) {
    return null;
  }
  const year = parseInt(match[1], 10);
  const monthNum = parseInt(match[2], 10);
  if (monthNum < 1 || monthNum > 12) {
    return null;
  }
  const from = `${year}-${month.slice(-2)}-01`;
  const lastDay = new Date(year, monthNum, 0).getDate();
  const to = `${year}-${month.slice(-2)}-${lastDay.toString().padStart(2, '0')}`;
  return { from, to };
}

// Create invoice and persist to database
export function invoiceCreateCommand(options: {
  project?: string;
  from?: string;
  to?: string;
  month?: string;
  rate?: string;
}): void {
  // Handle --month option
  // Get date range - use consistent Date instance
  const today = new Date();
  let fromDate = options.from;
  let toDate = options.to;
  if (options.month) {
    const range = parseMonthToRange(options.month);
    if (!range) {
      console.log();
      error('Invalid month format. Use YYYY-MM (e.g., 2025-01)');
      console.log();
      return;
    }
    fromDate = range.from;
    toDate = range.to;
  } else {
    // Default to first of current month and today
    const firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    fromDate = fromDate || firstOfMonth.toISOString().slice(0, 10);
    toDate = toDate || today.toISOString().slice(0, 10);
  }

  // Validate rate if provided
  let rate: number | undefined = undefined;
  if (options.rate) {
    const parsedRate = parseFloat(options.rate);
    if (!Number.isFinite(parsedRate) || parsedRate < 0) {
      error('Invalid rate: must be a non-negative number');
      console.log();
      return;
    }
    rate = parsedRate;
  }
  const data = generateInvoiceData({
    project: options.project,
    from: fromDate,
    to: toDate,
    rate,
  });

  if (!data) {
    console.log();
    if (options.project) {
      error(`Project "${options.project}" not found or no entries in period`);
    } else {
      error('No billable entries found in the specified period');
    }
    console.log();
    return;
  }

  // Get project ID
  let projectId: number | null = null;
  if (options.project) {
    const project = getProjectByName(options.project);
    if (project) {
      projectId = project.id;
    }
  }

  // Ensure we have valid dates
  const todayDate = new Date();
  const firstOfMonth = new Date(todayDate.getFullYear(), todayDate.getMonth(), 1);
  const finalFromDate = fromDate || firstOfMonth.toISOString().slice(0, 10);
  const finalToDate = toDate || todayDate.toISOString().slice(0, 10);

  // Create invoice in database
  const invoice = createInvoice({
    projectId,
    client: data.client,
    fromDate: finalFromDate,
    toDate: finalToDate,
    totalHours: data.totalHours,
    hourlyRate: data.rate,
    totalAmount: data.totalAmount,
    lineItems: data.entries.map(e => ({
      date: e.date,
      category: e.category,
      hours: e.hours,
      rate: e.rate,
      amount: e.amount,
      notes: e.notes || undefined,
    })),
  });

  console.log();
  success(`Invoice ${invoice.invoice_number} created`);
  console.log();
  console.log(`  Total Hours:  ${chalk.cyan(data.totalHours.toFixed(2))}`);
  console.log(`  Hourly Rate:  ${chalk.cyan('$' + data.rate.toFixed(2))}`);
  console.log(`  Total Amount: ${chalk.green('$' + data.totalAmount.toFixed(2))}`);
  console.log(`  Period:       ${fromDate || 'start'} to ${toDate || 'now'}`);
  console.log();
}

// List all invoices
export function invoiceListCommand(): void {
  ensureInvoicesTable();
  const invoices = getAllInvoices();

  console.log();
  if (invoices.length === 0) {
    info('No invoices found');
    console.log();
    return;
  }

  console.log(chalk.bold('Invoices'));
  console.log();

  // Table header
  const header = [
    'Number'.padEnd(12),
    'Date'.padEnd(12),
    'Period'.padEnd(24),
    'Hours'.padStart(8),
    'Amount'.padStart(12),
    'Status'.padEnd(8),
  ].join('  ');
  console.log(chalk.dim(header));
  console.log(chalk.dim('─'.repeat(80)));

  for (const inv of invoices) {
    const number = chalk.cyan(inv.invoice_number.padEnd(12));
    const date = inv.created_at.slice(0, 10).padEnd(12);
    const period = `${inv.from_date} - ${inv.to_date}`.padEnd(24);
    const hours = inv.total_hours.toFixed(2).padStart(8);
    const amount = chalk.green('$' + inv.total_amount.toFixed(2).padStart(10));
    const statusColors: Record<string, (s: string) => string> = {
      draft: chalk.yellow,
      sent: chalk.blue,
      paid: chalk.green,
    };
    const statusFn = statusColors[inv.status] || chalk.white;
    const status = statusFn(inv.status.padEnd(8));

    console.log(`${number}  ${date}  ${period}  ${hours}  ${amount}  ${status}`);
  }

  console.log();
}

// Show invoice details
export function invoiceShowCommand(idOrNumber: string): void {
  ensureInvoicesTable();

  // Try to find by number or ID
  let invoice: Invoice | null = null;
  if (idOrNumber.startsWith('INV-')) {
    invoice = getInvoiceByNumber(idOrNumber);
  } else {
    const id = parseInt(idOrNumber, 10);
    if (!isNaN(id)) {
      invoice = getInvoiceById(id);
    }
  }

  if (!invoice) {
    console.log();
    error(`Invoice "${idOrNumber}" not found`);
    console.log();
    return;
  }

  const lineItems = getInvoiceLineItems(invoice.id);

  console.log();
  console.log(chalk.bold(`Invoice ${invoice.invoice_number}`));
  console.log();
  console.log(`  Status:       ${invoice.status}`);
  console.log(`  Created:      ${invoice.created_at.slice(0, 10)}`);
  console.log(`  Period:       ${invoice.from_date} to ${invoice.to_date}`);
  if (invoice.client) {
    console.log(`  Client:       ${invoice.client}`);
  }
  console.log(`  Hourly Rate:  $${invoice.hourly_rate.toFixed(2)}`);
  console.log();
  console.log(chalk.bold('Line Items'));
  console.log();

  // Line items table
  const header = [
    'Date'.padEnd(12),
    'Category'.padEnd(16),
    'Hours'.padStart(8),
    'Amount'.padStart(12),
  ].join('  ');
  console.log(chalk.dim(header));
  console.log(chalk.dim('─'.repeat(52)));

  for (const item of lineItems) {
    const date = item.date.padEnd(12);
    const category = item.category.slice(0, 15).padEnd(16);
    const hours = item.hours.toFixed(2).padStart(8);
    const amount = ('$' + item.amount.toFixed(2)).padStart(12);
    console.log(`${date}  ${category}  ${hours}  ${amount}`);
  }

  console.log(chalk.dim('─'.repeat(52)));
  console.log(`${'Total'.padEnd(30)}  ${invoice.total_hours.toFixed(2).padStart(8)}  ${chalk.green('$' + invoice.total_amount.toFixed(2).padStart(10))}`);
  console.log();
}

// Export invoice to file
export function invoiceExportCommand(idOrNumber: string, options: {
  format?: string;
  output?: string;
}): void {
  ensureInvoicesTable();

  // Try to find by number or ID
  let invoice: Invoice | null = null;
  if (idOrNumber.startsWith('INV-')) {
    invoice = getInvoiceByNumber(idOrNumber);
  } else {
    const id = parseInt(idOrNumber, 10);
    if (!isNaN(id)) {
      invoice = getInvoiceById(id);
    }
  }

  if (!invoice) {
    console.log();
    error(`Invoice "${idOrNumber}" not found`);
    console.log();
    return;
  }

  const lineItems = getInvoiceLineItems(invoice.id);
  const format = options.format || 'html';

  // Build InvoiceData compatible structure
  const data: InvoiceData = {
    project: invoice.client || 'Project',
    client: invoice.client,
    period: `${invoice.from_date} to ${invoice.to_date}`,
    entries: lineItems.map(item => ({
      date: item.date,
      category: item.category,
      project: null,
      hours: item.hours,
      rate: item.rate,
      amount: item.amount,
      notes: item.notes,
    })),
    totalHours: invoice.total_hours,
    totalAmount: invoice.total_amount,
    rate: invoice.hourly_rate,
  };

  let content: string;
  let ext: string;
  if (format === 'html') {
    content = generateHtmlInvoice(data);
    ext = 'html';
  } else {
    content = generateTextInvoice(data);
    ext = 'txt';
  }

  const filename = options.output || `${invoice.invoice_number}.${ext}`;
  try {
    writeFileSync(filename, content);
    console.log();
    success(`Invoice exported to ${filename}`);
    console.log();
  } catch (err) {
    error(`Failed to write invoice to ${filename}: ${err instanceof Error ? err.message : 'Unknown error'}`);
    console.log();
    process.exit(1);
  }
}

// Delete invoice
export function invoiceDeleteCommand(idOrNumber: string): void {
  ensureInvoicesTable();

  // Try to find by number or ID
  let invoice: Invoice | null = null;
  if (idOrNumber.startsWith('INV-')) {
    invoice = getInvoiceByNumber(idOrNumber);
  } else {
    const id = parseInt(idOrNumber, 10);
    if (!isNaN(id)) {
      invoice = getInvoiceById(id);
    }
  }

  if (!invoice) {
    console.log();
    error(`Invoice "${idOrNumber}" not found`);
    console.log();
    return;
  }

  const deleted = deleteInvoice(invoice.id);
  if (deleted) {
    console.log();
    success(`Invoice ${invoice.invoice_number} deleted`);
    console.log();
  } else {
    console.log();
    error('Failed to delete invoice');
    console.log();
  }
}
